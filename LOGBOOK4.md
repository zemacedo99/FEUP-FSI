# Work performed during the week #4

## CTF

### Goal
- Log in in a wordpress server using a known CVE and retrieve the flag.

### Tasks
- While browsing the website, we found out it was using Wordpress version 5.8.1 and two plugins, WooCommerce plugin version 5.7.1 and Booster for WooCommerce plugin version 5.4.3 . We also found two users named "admin" and "Orval Sanford".

- Searching the web for known CVE's related to this Wordpress version and the plugins, we were presented with several possibilities to choose from. We endded up picking the CVE-2021-34646, which is a vulnerability that affected the WooCommmerce plugin version 5.4.3 and allowed us to bypass the authentication and gain admin priviledges.

- We found a python exploit to this CVE in the Exploit DB platform. By accessing the http://ctf-fsi.fe.up.pt:5001/wp-json/wp/v2/users/ , we realised that the "admin" id was 1 and used this value and the server link to execute the expoit.

- Three links were generated by the exploit. One of these links allowed us to log in as "admin" and from this point we only had to navigated to the private post and retrieve the flag.


## SeedLab

### Task 1 
- Using ``printenv`` ou ``env`` we listed the environment variables in the terminal.
- To create an environment variable we used ``export``, for example: ``export MYVAR=12 `` . We used the commands above to check that it was set correctly and also tried ``printenv MYVAR`` ( and ``env | grep MYVAR``) to print just our environment variable instead of all of them.
- Using ``unset`` we removed our environment variable, ``unset MYVAR`` in this specific case. After this, running ``printenv MYVAR`` in the terminal returned nothing.

### Task 2
- Compiling and running the given program, using ``fork()``, it created a child process, which printed environment variables in the terminal. In this first step, the parent process executed no tasks. 
- Following the step 2 instructions, this time the child process executed no tasks while the parent process printed environment variables in the terminal.
- Comparing the results from both step 1 and step 2, we noticed no differences. This led us to the conclusion that the child and parent processes share the same environment variables.

### Task 3
- Running the program given in the first step, there was nothing printed in the terminal.
- After making the changes listed in the second step, the environment variables were printed to the terminal.
- The new program gets its environment variables from the ``extern char **environ`` variable that must be declared in the user program, but is declared in the header file ``unistd.h`` and therefore doesn't need to be defined by the user.

### Task 4 
- Compiling and running the given program, we print the enviroment variables in the terminal.
- ``system()`` function call the function ``execl()`` that executes the /bin/sh program first, creating a new shell
- ``execl()`` calls ``execve()``passing to it the environment variables array.
- Verifying that using the fuction ``system()`` the environment variables is passed to the new program /bin/sh.

### Task 5
- All of the environment variables set in step 3 were printed to the console.

### Task 6
- With the command ``export PATH=/home/ourCommands:$PATH`` we can add the directory /home/ourCommands to the
beginning of the PATH environment variable.
- After this, we can create a executable file ls (gcc ls.c -o ls) in this directory, where ls.c instead of listing the content of the current directory can do wath we want, int this case, just print "Hello World".
- Every time ls is executed in this directory, it will not do his proper function but whatever we defined in the executable ls.
